# NULP Dynamic Page Rendering System Documentation

## Overview

This document explains how the NULP (National Urban Learning Platform) dynamic page rendering system works, including its integration with the CMS (Content Management System) and support for static hosting.

## Architecture Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Static Host   ‚îÇ    ‚îÇ  Next.js App    ‚îÇ    ‚îÇ   CMS APIs      ‚îÇ
‚îÇ   (/out folder) ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  (Client-Side)  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ (devnulp.niua) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## System Components

### 1. Next.js Dynamic Routing

- **File**: `pages/[slug].tsx`
- **Purpose**: Handles all dynamic pages (e.g., `/nulp-articles`, `/learnathon`, etc.)
- **Type**: Static Site Generation (SSG) with client-side data fetching

### 2. CMS Integration

- **Base URL**: `https://devnulp.niua.org/mw-cms/api/v1/`
- **Services**: Located in `services/api.ts` and `services/menus.ts`

### 3. Static Hosting Support

- **Build Output**: `/out` folder (generated by `next build && next export`)
- **Hosting**: Static file server (no Node.js runtime required)

## How Dynamic Page Rendering Works

### Phase 1: Build Time (Static Generation)

```typescript
// pages/[slug].tsx - getStaticPaths
export const getStaticPaths: GetStaticPaths = async () => {
  // Fetch menu items from CMS
  const menusResponse = await menusApi.getHomepageMenus();

  // Generate paths for all menu items
  const paths =
    menusResponse.data?.map((item) => ({
      params: { slug: extractSlugFromLink(item.link) },
    })) || [];

  return {
    paths,
    fallback: "blocking", // Allow new pages to be generated on-demand
  };
};
```

**What happens:**

1. Fetches all menu items from CMS during build
2. Generates static paths for each menu item
3. Creates HTML files in `/out` folder for each path
4. Uses `fallback: "blocking"` to handle new pages not built initially

### Phase 2: Runtime (Client-Side Data Fetching)

#### Step 1: Initial Page Load

```typescript
// Component initialization
const DynamicPage: React.FC<DynamicPageProps> = ({ slug, ... }) => {
  const router = useRouter();
  const [clientSlug, setClientSlug] = useState(slug);
  const [fullContent, setFullContent] = useState(null);
  const [menuItem, setMenuItem] = useState(null);
  const [loading, setLoading] = useState(false);
```

#### Step 2: URL Slug Extraction

```typescript
// Extract slug from browser URL
useEffect(() => {
  if (typeof window !== "undefined") {
    const currentPath = window.location.pathname;
    const urlSlug = currentPath.startsWith("/")
      ? currentPath.slice(1)
      : currentPath;

    // Update client slug if different from props
    if (urlSlug && urlSlug !== clientSlug) {
      setClientSlug(urlSlug);
      // Clear content for new page
      setFullContent(null);
      setMenuItem(null);
    }
  }
}, [slug, clientSlug]);
```

#### Step 3: Navigation Detection

```typescript
// Listen for route changes (client-side navigation)
useEffect(() => {
  const handleRouteChange = (url: string) => {
    const newSlug = url.startsWith("/") ? url.slice(1) : url;
    if (newSlug && newSlug !== clientSlug) {
      setClientSlug(newSlug);
      setFullContent(null);
      setMenuItem(null);
      setLoading(true);
    }
  };

  router.events.on("routeChangeStart", handleRouteChange);
  return () => router.events.off("routeChangeStart", handleRouteChange);
}, [router, clientSlug]);
```

#### Step 4: CMS Data Fetching

```typescript
// Fetch data from CMS APIs
useEffect(() => {
  if (!isClient || !clientSlug) return;

  const fetchData = async () => {
    setLoading(true);

    try {
      // 1. Fetch menu data
      const menusResponse = await menusApi.getHomepageMenus();
      const currentMenuItem = menusResponse.data?.find((item) => {
        const menuSlug = extractSlugFromLink(item.link);
        return menuSlug === clientSlug;
      });
      setMenuItem(currentMenuItem || null);

      // 2. Fetch page content
      const fullContentResponse = await contentApi.getFullPageContent(
        clientSlug
      );

      if (fullContentResponse.success && fullContentResponse.data) {
        setFullContent(fullContentResponse.data);
      } else {
        // Fallback: fetch individual components
        const [bannersResponse, articlesResponse] = await Promise.all([
          contentApi.getBannersByMenu(clientSlug),
          contentApi.getArticlesByMenu(clientSlug),
        ]);

        const combinedContent = {
          page_title: currentMenuItem?.title || clientSlug,
          menu_slug: clientSlug,
          banners: bannersResponse.data || [],
          articles: articlesResponse.data || [],
        };
        setFullContent(combinedContent);
      }
    } catch (error) {
      console.error("Error fetching data:", error);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, [isClient, clientSlug, fullContent]);
```

## CMS API Integration

### API Endpoints Used

#### 1. Menu API (`services/menus.ts`)

```typescript
// Endpoint: /homepage/menus?state=Published
await menusApi.getHomepageMenus();
```

**Response Structure:**

```json
{
  "success": true,
  "data": [
    {
      "id": 1,
      "title": "NULP Articles",
      "link": "/nulp-articles",
      "state": "Published"
    }
  ]
}
```

#### 2. Full Page Content API (`services/api.ts`)

```typescript
// Endpoint: /homepage/page-contents?menu={slug}&state=Published
await contentApi.getFullPageContent(slug);
```

**Response Structure:**

```json
{
  "success": true,
  "data": {
    "page_title": "NULP Articles",
    "menu_slug": "nulp-articles",
    "articles": [...],
    "banners": [...]
  }
}
```

#### 3. Individual Component APIs

```typescript
// Banners: /homepage/banners?menu={slug}&state=Published
await contentApi.getBannersByMenu(slug);

// Articles: /homepage/articles?menu={slug}&state=Published
await contentApi.getArticlesByMenu(slug);
```

### CMS Data Flow

```
CMS Admin Panel
       ‚Üì
   Add/Edit Content
       ‚Üì
   Publish Content
       ‚Üì
API Endpoints Updated
       ‚Üì
Client-Side Fetch
       ‚Üì
Page Renders New Content
```

## Page Rendering Components

### 1. Dynamic Page Layout

```typescript
<DynamicPageLayout
  title={pageTitle}
  content={content}
  meta={{ description: pageDescription }}
/>
```

### 2. Content Components

- **DynamicPageBanner**: Renders banner content
- **DynamicPageArticles**: Renders article content
- **Fallback Content**: Shows when no content is available

### 3. Loading States

- **Initial Load**: Full-page loading spinner
- **Navigation**: Small loading indicator
- **Content Updates**: Smooth transitions

## Static Hosting Deployment

### Build Process

```bash
# 1. Build the application
npm run build

# 2. Export static files
npm run export  # or next export

# 3. Deploy /out folder to static host
# The /out folder contains:
# - HTML files for each dynamic route
# - Static assets (CSS, JS, images)
# - Pre-built JSON data
```

### File Structure in /out

```
/out/
‚îú‚îÄ‚îÄ index.html                 # Homepage
‚îú‚îÄ‚îÄ nulp-articles.html         # Dynamic page
‚îú‚îÄ‚îÄ learnathon.html           # Dynamic page
‚îú‚îÄ‚îÄ _next/
‚îÇ   ‚îú‚îÄ‚îÄ static/               # Static assets
‚îÇ   ‚îî‚îÄ‚îÄ data/                 # Pre-built data
‚îî‚îÄ‚îÄ images/                   # Static images
```

## Key Features

### ‚úÖ **Real-Time Content Updates**

- Content updates in CMS appear immediately
- No rebuild/redeploy required
- Works with static hosting

### ‚úÖ **Client-Side Navigation**

- Smooth navigation between dynamic pages
- Proper loading states
- URL-based routing

### ‚úÖ **SEO Friendly**

- Static HTML for initial load
- Dynamic meta tags
- Proper page titles

### ‚úÖ **Performance Optimized**

- Static file serving
- Client-side caching
- Minimal JavaScript bundle

### ‚úÖ **Development Experience**

- Hot reloading in development
- Comprehensive debugging
- Error handling

## Debugging Features

### Debug Information Panel

```html
<div style="background: #f0f8ff; padding: 1rem; margin: 1rem 0;">
  <strong>üîç Debug Info:</strong><br />
  ‚Ä¢ Client-side: Active/Loading<br />
  ‚Ä¢ Loading: Yes/No<br />
  ‚Ä¢ Full Content: X articles, Y banners<br />
  ‚Ä¢ Menu Item: Menu Title<br />
  ‚Ä¢ Props Slug: from-next-props<br />
  ‚Ä¢ Client Slug: from-url<br />
  ‚Ä¢ URL: /current-path<br />
</div>
```

### Console Logging

- Route change detection
- Slug transitions
- API call results
- Content updates
- Error tracking

## Error Handling

### 1. API Failures

- Graceful fallback to individual API calls
- Error logging for debugging
- Fallback content display

### 2. Missing Content

- Shows "Content being prepared" message
- Includes page/slug information
- Maintains page structure

### 3. Navigation Issues

- Route change detection
- State cleanup on navigation
- Loading state management

## Performance Considerations

### 1. Caching Strategy

- Static HTML files cached by CDN
- Client-side data fetching for freshness
- Session storage for menu data (in Header component)

### 2. Loading Optimization

- Progressive content loading
- Skeleton screens during fetch
- Minimal layout shift

### 3. Bundle Size

- Tree-shaking for unused code
- Dynamic imports where possible
- Optimized dependencies

## Maintenance & Updates

### Adding New Dynamic Pages

1. Add menu item in CMS with proper link
2. Add corresponding content in CMS
3. No code changes required (automatic)

### CMS Content Updates

1. Update content in CMS admin panel
2. Publish changes
3. Content appears immediately on site

### Code Updates

1. Modify components as needed
2. Run `npm run build`
3. Deploy new `/out` folder

## Troubleshooting

### Common Issues

#### 1. "Page: undefined" Error

- **Cause**: Missing fallback in page title calculation
- **Solution**: Added comprehensive fallback chain

#### 2. Navigation Not Working

- **Cause**: Route change not detected
- **Solution**: Added router event listeners

#### 3. Content Not Loading

- **Cause**: Client-side JavaScript not executing
- **Solution**: Added proper client-side detection

#### 4. Static Hosting Issues

- **Cause**: Server-side features used
- **Solution**: Pure client-side implementation

### Debug Steps

1. Check browser console for errors
2. Verify API responses in Network tab
3. Check debug info panel on page
4. Verify CMS content is published

## Conclusion

This dynamic page rendering system provides:

- **Flexibility**: Easy content management via CMS
- **Performance**: Static hosting with dynamic content
- **Reliability**: Robust error handling and fallbacks
- **Maintainability**: Clean separation of concerns
- **Scalability**: Handles unlimited dynamic pages

The system successfully combines the benefits of static site generation with the flexibility of dynamic content management, making it ideal for the NULP platform's requirements.
